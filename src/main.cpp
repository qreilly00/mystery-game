//include classes and headers
#include "../inc/common.hpp"
#include "BasicUtils.hpp"

class BasicShape {
protected:
    sf::RectangleShape shape;
public:
    // Init class.
    BasicShape();
    BasicShape(sf::Vector2f, sf::Vector2f, float, float, sf::Color);

    // Get and set util for all shape properties.
    sf::RectangleShape& getShape();
};

BasicShape::BasicShape() {
    // A basic property setup.
    shape.setSize(sf::Vector2f(32, 32));
    shape.setPosition(sf::Vector2f(0, 0));

    shape.setFillColor(sf::Color::White);
}

BasicShape::BasicShape(sf::Vector2f size, sf::Vector2f position, float spd, float spdMlt, sf::Color clr) {
    // A basic property setup, tailored for a specific purpose.
    shape.setSize(size);
    shape.setPosition(position);

    shape.setFillColor(clr);
}

sf::RectangleShape& BasicShape::getShape() {return shape;}

class Entity : public BasicShape {
private:
    float speed;
    float speedMultiplier;
public:
    // Init class.
    Entity();
    Entity(sf::Vector2f size, sf::Vector2f position, float spd, float spdMlt, sf::Color clr);

    // Property get utils.
    float getSpeed();
    float getSpeedMultiplier();

    // Property set utils.
    void setSpeed(float);
    void setSpeedMultiplier(float);
};

Entity::Entity() {
    // A basic property setup.
    shape.setSize(sf::Vector2f(32, 32));
    shape.setPosition(sf::Vector2f(0, 0));

    speed = 100;
    speedMultiplier = 1;

    shape.setFillColor(sf::Color::White);
}

Entity::Entity(sf::Vector2f size, sf::Vector2f position, float spd, float spdMlt, sf::Color clr) {
    // A basic property setup, tailored for a specific purpose.
    shape.setSize(size);
    shape.setPosition(position);

    speed = spd;
    speedMultiplier = spdMlt;

    shape.setFillColor(clr);
}

float Entity::getSpeed() {return speed;}
float Entity::getSpeedMultiplier() {return speedMultiplier;}

void Entity::setSpeed(float spd) {speed = spd;}
void Entity::setSpeedMultiplier(float spdMlt) {speedMultiplier = spdMlt;}

class Base {
private:
    // Saves the amount of time generated by the timeUtil.
    BasicUtils ut;
    float totalTime;

    sf::RenderWindow window;
    Entity player;

    std::vector<sf::FloatRect> playerBorders;
    sf::Vector2f playerMoveAmount;

    std::vector<BasicShape> collides;

public:

    // Init class.
    Base();

    // Init functions.
    void createWindow();
    void createPlayer();

    // Main Functions.
    bool gameLoop();
    bool checkControls();

    // Required by checkControls().
    float calculateFrameStep();
    void checkMoves();

    // Required by checkMoves().
    void updatePlayerBorders();

    void drawWindow();
};

Base::Base() {
    //tu.setTime();
    totalTime = 0;

    playerBorders.resize(4);

    // Example.
    //collides.push_back(BasicShape(sf::Vector2f(64, 64), sf::Vector2f(512, 512), 0, 1, sf::Color::White));
}

void Base::createWindow() {
    window.create(sf::VideoMode(1600 , 900), "SFML works!"/*, sf::Style::Fullscreen*/);
    //window.setFramerateLimit(10);
}

void Base::createPlayer() {
    player.getShape().setSize(sf::Vector2f(64, 64));
    player.getShape().setPosition(sf::Vector2f(64, 32));
    player.getShape().setFillColor(sf::Color::Blue);
}

bool Base::gameLoop() {
    ut.setTime();
    totalTime = ut.getTime();

    bool exit = 0;

    exit =
    checkControls();
    checkMoves();
    drawWindow();

    playerMoveAmount = sf::Vector2f(0, 0);

    return exit;
}

bool Base::checkControls() {
    sf::Event event;
    while (window.pollEvent(event)) {
        if (event.type == sf::Event::Closed || sf::Keyboard::isKeyPressed(sf::Keyboard::Escape)) {
            window.close();
            return 1;
        }
    }

    // Controls.
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::W)) {
        playerMoveAmount += sf::Vector2f(0, -calculateFrameStep());
    }
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::A)) {
        playerMoveAmount += sf::Vector2f(-calculateFrameStep(), 0);
    }
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::S)) {
        playerMoveAmount += sf::Vector2f(0, calculateFrameStep());
    }
    if (sf::Keyboard::isKeyPressed(sf::Keyboard::D)) {
        playerMoveAmount += sf::Vector2f(calculateFrameStep(), 0);
    }

    //if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {}

    return 0;
}

float Base::calculateFrameStep() {return (player.getSpeed() * player.getSpeedMultiplier()) * totalTime;}

void Base::checkMoves() {
    updatePlayerBorders();

    for(auto x : collides) {
        // Figure out before-hand, the distance between each side of the shape and the current object.
        float playerLeftDistance = (x.getShape().getPosition().x + x.getShape().getSize().x) - player.getShape().getPosition().x;
        float playerRightDistance = player.getShape().getPosition().x + player.getShape().getSize().x - (x.getShape().getPosition().x);
        float playerTopDistance = (x.getShape().getPosition().y + x.getShape().getSize().y) - player.getShape().getPosition().y;
        float playerBottomDistance = player.getShape().getPosition().y + player.getShape().getSize().y - (x.getShape().getPosition().y);

        // While moving left, right, top and bottom.
        if(playerMoveAmount.x < 0 && playerBorders[0].intersects(x.getShape().getGlobalBounds())) {
            if(playerMoveAmount.x > (playerLeftDistance)) {
                playerMoveAmount.x = playerLeftDistance;
            } else {
                playerMoveAmount.x = 0;
            }
        }
        if(playerMoveAmount.x > 0 && playerBorders[1].intersects(x.getShape().getGlobalBounds())) {
            if(-playerMoveAmount.x > (playerRightDistance)) {
                playerMoveAmount.x = -playerRightDistance;
            } else {
                playerMoveAmount.x = 0;
            }
        }
        if(playerMoveAmount.y < 0 && playerBorders[2].intersects(x.getShape().getGlobalBounds())) {
            if(playerMoveAmount.y > (playerTopDistance)) {
                playerMoveAmount.y = playerTopDistance;
            } else {
                playerMoveAmount.y = 0;
            }
        }
        if(playerMoveAmount.y > 0 && playerBorders[3].intersects(x.getShape().getGlobalBounds())) {
            if(-playerMoveAmount.y > (playerBottomDistance)) {
                playerMoveAmount.y = -playerBottomDistance;
            } else {
                playerMoveAmount.y = 0;
            }
        }
    }

    player.getShape().move(playerMoveAmount);
}

void Base::updatePlayerBorders() {
    // Update left, right, top and Bottom border.
    playerBorders[0] = (sf::FloatRect(
        player.getShape().getPosition().x - 1,
        player.getShape().getPosition().y,
        1,
        player.getShape().getSize().y
    ));
    playerBorders[1] = (sf::FloatRect(
        player.getShape().getPosition().x + player.getShape().getSize().x,
        player.getShape().getPosition().y,
        1,
        player.getShape().getSize().y
    ));
    playerBorders[2] = (sf::FloatRect(
        player.getShape().getPosition().x,
        player.getShape().getPosition().y - 1,
        player.getShape().getSize().y,
        1
    ));
    playerBorders[3] = (sf::FloatRect(
        player.getShape().getPosition().x,
        player.getShape().getPosition().y + player.getShape().getSize().y,
        player.getShape().getSize().y,
        1
    ));
}

void Base::drawWindow() {
    window.clear(sf::Color::Black);
    window.draw(player.getShape());

    for(auto x : collides) {window.draw(x.getShape());}
    //for(auto x : jigSawPieces) {}

    window.display();
}

int main() {

    Base b;
    b.createWindow();
    b.createPlayer();

    bool exit = 0;
    while(exit == 0) {
        exit =
        b.gameLoop();
    }

    // Exit program.
    return 0;
}
